# Start/End Print Macros and KAMP Adaptive Meshing
# For Ender 3 V2 with BLTouch and KAMP

#====================================================================
# PRINT START/END
#====================================================================

[gcode_macro PRINT_START]
description: Start print routine with heating and adaptive meshing
gcode:
    {% set EXTRUDER = params.EXTRUDER_TEMP|default(200)|int %}
    {% set BED = params.BED_TEMP|default(60)|int %}
    
    # Status update
    RESPOND MSG="Starting print - Bed: {BED}C, Extruder: {EXTRUDER}C"
    
    # Pre-heat extruder to prevent oozing during mesh
    M104 S150
    
    # Heat bed and wait
    M140 S{BED}
    M190 S{BED}
    
    # Home if not already homed
    _CHOME
    
    # Adaptive bed mesh (KAMP)
    BED_MESH_CALIBRATE
    
    # Park near print area (KAMP)
    Smart_Park
    
    # Final extruder heating
    M104 S{EXTRUDER}
    M109 S{EXTRUDER}
    
    # Purge line (KAMP)
    LINE_PURGE
    
    # Reset extruder
    G92 E0
    
    # Move up slightly
    G0 Z1 F3000

    # Cap acceleration at 500 for first layer - slicer takes over after this
    SET_VELOCITY_LIMIT ACCEL=500
    
    RESPOND MSG="Print starting!"

[gcode_macro PRINT_END]
description: End print routine with safe parking and shutdown
gcode:
    # Get print stats
    {% set max_z = printer.toolhead.axis_maximum.z|float %}
    {% set act_z = printer.toolhead.position.z|float %}
    
    # Retract and move away
    G91
    G1 E-4 F2700
    G0 X5 Y5 F5000
    
    # Raise Z safely (don't exceed max)
    {% if act_z < (max_z - 10) %}
        G0 Z10 F3000
    {% else %}
        G0 Z{max_z - act_z} F3000
    {% endif %}
    
    # Return to absolute positioning
    G90
    
    # Present print - front of bed, max Y (works for all bed sizes)
    {% set y_present = printer.toolhead.axis_maximum.y|float %}
    G0 X0 Y{y_present} F5000
    
    # Shutdown
    TURN_OFF_HEATERS
    M107  # Fan off
    M84   # Motors off
    
    RESPOND MSG="Print complete!"

#====================================================================
# CONDITIONAL HOMING
#====================================================================

[gcode_macro _CHOME]
description: Home only if not already homed
gcode:
    {% if printer.toolhead.homed_axes != "xyz" %}
        G28
    {% endif %}

#====================================================================
# ADAPTIVE BED MESH (KAMP-based)
#====================================================================

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE
description: Perform adaptive bed mesh based on print area
variable_buffer: 2
gcode:
    # Get bed_mesh config
    {% set bedMeshConfig = printer['configfile'].config["bed_mesh"] %} 
    {% set bed_mesh_min = bedMeshConfig.mesh_min %}
    {% set bed_mesh_max = bedMeshConfig.mesh_max %}
    
    # Get print bounds from exclude_object
    {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
    {% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
    {% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
    {% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
    {% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}
    
    # Check if we have an existing mesh
    {% if printer["bed_mesh"].profile_name == '' %}
        { action_respond_info("No existing bed mesh found.") }
    {% endif %}

    # Home if needed
    {% if printer.toolhead.homed_axes != "xyz" %}
        G28
    {% endif %}

    # Get probe offset
    {% set probeConfig = printer['configfile'].config["bltouch"] %}
    {% if probeConfig %}
        {% set OffsetX = probeConfig.x_offset|default(0)|float %}
        {% set OffsetY = probeConfig.y_offset|default(0)|float %}
    {% endif %}

    {% set print_min_x = x_min|float %}
    {% set print_min_y = y_min|float %}
    {% set print_max_x = x_max|float %}
    {% set print_max_y = y_max|float %}
    
    {% set mesh_min_x = bed_mesh_min.split(",")[0]|float %}
    {% set mesh_min_y = bed_mesh_min.split(",")[1]|float %}
    {% set mesh_max_x = bed_mesh_max.split(",")[0]|float %}
    {% set mesh_max_y = bed_mesh_max.split(",")[1]|float %}
 
    # Ensure print area is within mesh bounds
    {% if (print_min_x < mesh_min_x) or (print_max_x > mesh_max_x) or (print_min_y < mesh_min_y) or (print_max_y > mesh_max_y) %}
        {% set print_min_x = mesh_min_x %}
        {% set print_min_y = mesh_min_y %}
        {% set print_max_x = mesh_max_x %}
        {% set print_max_y = mesh_max_y %}
    {% endif %}
  
    {% if (print_min_x < print_max_x) and (print_min_y < print_max_y) %}
        {% set minimum_probe_count = 3 %}
        {% set medium_probe_count = 5 %}
 
        {% set probe_count = bedMeshConfig.probe_count.split(",") %}
        {% set probe_count_x = probe_count[0]|int %}
        {% if probe_count.__len__() > 1 %}
            {% set probe_count_y = probe_count[1]|int %}
        {% else %}
            {% set probe_count_y = probe_count_x|int %}
        {% endif %}
        {% set relative_reference_index = bedMeshConfig.relative_reference_index %}

        # Adjust probe count based on print area size
        # If print area X is smaller than 75% of bed, use 5 probes
        {% if print_max_x - print_min_x < (mesh_max_x - mesh_min_x) * 0.75 %}
            {% set probe_count_x = medium_probe_count %}
        {% endif %}

        # If print area Y is smaller than 75% of bed, use 5 probes
        {% if print_max_y - print_min_y < (mesh_max_y - mesh_min_y) * 0.75 %}
            {% set probe_count_y = medium_probe_count %}
        {% endif %}

        # If print area X is smaller than 50% of bed, use 3 probes
        {% if print_max_x - print_min_x < (mesh_max_x - mesh_min_x) * 0.50 %}
            {% set probe_count_x = minimum_probe_count %}
        {% endif %}

        # If print area Y is smaller than 50% of bed, use 3 probes
        {% if print_max_y - print_min_y < (mesh_max_y - mesh_min_y) * 0.50 %}
            {% set probe_count_y = minimum_probe_count %}
        {% endif %}

        # Add buffer around print area
        {% if print_min_x - buffer >= mesh_min_x %}
            {% set mesh_min_x = print_min_x - buffer %}
        {% endif %}

        {% if print_min_y - buffer >= mesh_min_y %}
            {% set mesh_min_y = print_min_y - buffer %}
        {% endif %}

        {% if print_max_x + buffer <= mesh_max_x %}
            {% set mesh_max_x = print_max_x + buffer %}
        {% endif %}

        {% if print_max_y + buffer <= mesh_max_y %}
            {% set mesh_max_y = print_max_y + buffer %}
        {% endif %}

        { action_respond_info("Adaptive Mesh - Min: %s,%s Max: %s,%s Probes: %s,%s" % (mesh_min_x, mesh_min_y, mesh_max_x, mesh_max_y, probe_count_x, probe_count_y)) }

        # Run mesh calibration
        {% if relative_reference_index == 0 or relative_reference_index == null %}
            _BED_MESH_CALIBRATE mesh_min={mesh_min_x},{mesh_min_y} mesh_max={mesh_max_x},{mesh_max_y} probe_count={probe_count_x},{probe_count_y}
        {% else %}
            {% set relative_reference_index = ((probe_count_x * probe_count_y - 1) / 2)|int %}
            { action_respond_info("Relative reference index: %s" % relative_reference_index) }
            _BED_MESH_CALIBRATE mesh_min={mesh_min_x},{mesh_min_y} mesh_max={mesh_max_x},{mesh_max_y} probe_count={probe_count_x},{probe_count_y} relative_reference_index={relative_reference_index}
        {% endif %}
    {% else %}
        # No print bounds found, do full mesh
        { action_respond_info("No print bounds detected - performing full bed mesh") }
        _BED_MESH_CALIBRATE
    {% endif %}

#====================================================================
# TEMPERATURE WAITING WITH STATUS
#====================================================================

[gcode_macro M190]
rename_existing: M190.1
description: Wait for bed temperature
gcode:
    {% if printer["gcode_macro status_heating"] != null %}
        status_heating
    {% endif %}
    M190.1 { rawparams }
    {% if printer["gcode_macro status_ready"] != null %}
        status_ready
    {% endif %}

[gcode_macro M109]
rename_existing: M109.1
description: Wait for extruder temperature
gcode:
    {% if printer["gcode_macro status_heating"] != null %}
        status_heating
    {% endif %}
    M109.1 { rawparams }
    {% if printer["gcode_macro status_ready"] != null %}
        status_ready
    {% endif %}

#====================================================================
# FILAMENT CHANGE
#====================================================================

[gcode_macro M600]
description: Filament change
gcode:
    {% set X = params.X|default(50)|float %}
    {% set Y = params.Y|default(0)|float %}
    {% set Z = params.Z|default(10)|float %}
    
    SAVE_GCODE_STATE NAME=M600_state
    PAUSE
    G91
    G1 E-.8 F2700
    G1 Z{Z}
    G90
    G1 X{X} Y{Y} F3000
    G91
    G1 E-50 F1000
    RESTORE_GCODE_STATE NAME=M600_state

#====================================================================
# PAUSE/RESUME CONTROL
#====================================================================

[pause_resume]
recover_velocity: 300.0

[gcode_macro PAUSE]
rename_existing: PAUSE_BASE
description: Pause the print and park toolhead
gcode:
    PAUSE_BASE
    _TOOLHEAD_PARK_PAUSE_CANCEL

[gcode_macro RESUME]
rename_existing: RESUME_BASE
description: Resume the paused print
gcode:
    {% set extrude = printer['gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL'].extrude %}
    {% if 'VELOCITY' in params|upper %}
        {% set get_params = ('VELOCITY=' + params.VELOCITY) %}
    {% else %}
        {% set get_params = "" %}
    {% endif %}
    
    {% if printer.extruder.can_extrude|lower == 'true' %}
        M83
        G1 E{extrude} F2100
        {% if printer.gcode_move.absolute_extrude|lower == 'true' %}
            M82
        {% endif %}
    {% else %}
        {action_respond_info("Extruder not hot enough")}
    {% endif %}
    
    RESUME_BASE {get_params}

[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description: Park toolhead safely during pause/cancel
variable_extrude: 1.0
gcode:
    # Park position - center X, max Y
    {% set x_park = printer.toolhead.axis_maximum.x|float / 2 %}
    {% set y_park = printer.toolhead.axis_maximum.y %}
    {% set z_park_delta = 2.0 %}
    
    # Calculate safe Z lift
    {% set max_z = printer.toolhead.axis_maximum.z|float %}
    {% set act_z = printer.toolhead.position.z|float %}
    {% if act_z < (max_z - z_park_delta) %}
        {% set z_safe = z_park_delta %}
    {% else %}
        {% set z_safe = max_z - act_z %}
    {% endif %}
    
    # Retract if extruder is hot
    {% if printer.extruder.can_extrude|lower == 'true' %}
        M83
        G1 E-{extrude} F2100
        {% if printer.gcode_move.absolute_extrude|lower == 'true' %}
            M82
        {% endif %}
    {% else %}
        {action_respond_info("Extruder not hot enough")}
    {% endif %}
    
    # Park if homed
    {% if "xyz" in printer.toolhead.homed_axes %}
        G91
        G1 Z{z_safe} F900
        G90
        G1 X{x_park} Y{y_park} F6000
        {% if printer.gcode_move.absolute_coordinates|lower == 'false' %}
            G91
        {% endif %}
    {% else %}
        {action_respond_info("Printer not homed")}
    {% endif %}

#====================================================================
# STATUS PLACEHOLDER MACROS (for LED/display integration)
#====================================================================

[gcode_macro STATUS_READY]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_OFF]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_BUSY]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_HEATING]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_LEVELING]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_CLEANING]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_MESHING]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_CALIBRATING_Z]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro STATUS_PRINTING]
gcode:
    # Placeholder for future LED/display integration

[gcode_macro SET_NOZZLE_LEDS_ON]
gcode:
    # Placeholder for future LED integration

[gcode_macro SET_LOGO_LEDS_OFF]
gcode:
    # Placeholder for future LED integration

[gcode_macro SET_NOZZLE_LEDS_OFF]
gcode:
    # Placeholder for future LED integration

#====================================================================
# EXCLUDE OBJECT SUPPORT
#====================================================================

[exclude_object]
